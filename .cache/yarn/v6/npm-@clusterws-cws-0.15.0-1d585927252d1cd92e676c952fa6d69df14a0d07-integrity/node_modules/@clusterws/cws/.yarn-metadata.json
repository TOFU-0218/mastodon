{
  "manifest": {
    "name": "@clusterws/cws",
    "version": "0.15.0",
    "main": "./dist/index.js",
    "types": "./dist/index.d.ts",
    "description": "ClusterWS cWS custom fork of uWebSockets 0.14",
    "scripts": {
      "install": "node-gyp rebuild > build_log.txt 2>&1 || exit 0",
      "build": "ts-builder -c ./tsbuild.json"
    },
    "engines": {
      "node": ">=8.12.0"
    },
    "keywords": [
      "tiny",
      "websocket",
      "clusterws",
      "cws"
    ],
    "license": "MIT",
    "devDependencies": {
      "@types/node": "^10.7.0",
      "ts-builder": "0.9.0"
    },
    "_registry": "npm",
    "_loc": "/home/mastodon/.cache/yarn/v6/npm-@clusterws-cws-0.15.0-1d585927252d1cd92e676c952fa6d69df14a0d07-integrity/node_modules/@clusterws/cws/package.json",
    "readmeFilename": "README.md",
    "readme": "<h1 align=\"center\">ClusterWS/cWS Implementation</h1>\n<h6 align=\"center\">Modified version of <a href=\"https://github.com/uNetworking/uWebSockets/tree/v0.14\">uWebSockets v0.14</a></h6>\n\n<p align=\"center\">\n <img src=\"https://cdn.rawgit.com/goriunov/159120ca6a883d8d4e75543ec395d361/raw/d22028ecc726d7d3cc30a2a85cc7cc454b0afada/clusterws.svg\" width=\"450\">\n</p>\n\n<i>This module is modified version of the uWebSockets v0.14 with some minor tweaks in C++ code and complete rewrite of JS code to TypeScript. Original software is available in <a href=\"https://github.com/uNetworking/uWebSockets/tree/v0.14\">uWebSockets v0.14</a> repository.</i>\n\n<a href=\"https://badge.fury.io/js/%40clusterws%2Fcws\"><img src=\"https://badge.fury.io/js/%40clusterws%2Fcws.svg\" alt=\"npm version\" height=\"22\"></a>\n\nThis repository is based on the <a href=\"https://github.com/uNetworking/uWebSockets/tree/v0.14\">uWebSockets v0.14</a> therefore has two licence [ClusterWS MIT](https://github.com/ClusterWS/uWS/blob/master/LICENSE) and [Alex Hultman ZLIB](https://github.com/ClusterWS/uWS/blob/master/src/LICENSE).\n\nBig thanks to [SirAnthony](https://github.com/SirAnthony) for ssl workaround (has been taken from [SirAnthony's uWebSockets fork](https://github.com/hola/uWebSockets-bindings)).\n\n\n### All breaking changes from released version will be included in [CHANGELOG.md](./CHANGELOG.md)\n\n**Consider to support development:**\n- [Buy a coffee (via PayPal)](https://www.paypal.me/goriunov)\n- [Become a Backer on Patreon](https://www.patreon.com/clusterws) \n\n## Documentation\n\n### Installation\n\n```js\nnpm i @clusterws/cws\n```\n\n\n### WebSocket Server\nTo find about what types and parameters are accepted please check `dist/index.d.ts` file.\n\n```js \nconst { WebSocketServer } = require('@clusterws/cws');\n\nconst server = new WebSocketServer({\n  /**\n   *  Server options\n   * \n   *  path?: string,\n   *  port?: number,\n   *  host?: string;\n   *  server?: HTTP.Server | HTTPS.Server,\n   *  noDelay?: boolean,\n   *  maxPayload?: number,\n   *  perMessageDeflate?: {\n   *     serverNoContextTakeover: boolean\n   *  };\n   *  verifyClient?: (info: ConnectionInfo, next: Listener) => void\n   * \n   * For more type information check dist/index.d.ts file\n  */\n});\n\n\n/**\n * To accept WebSocket connections use on connection method\n * \n * socket: WebSocket client\n * upgReq: upgrade request\n*/\nserver.on('connection', (socket, upgReq) => {\n    /** allow you to get remoteAddress info */ \n    let address = socket._socket;\n\n    /**\n      * on 'message' will be called when new message arrives from this client\n      * \n      * msg: string | binary\n    */\n    socket.on('message', (msg) => { });\n\n    /**\n      * on 'close' will be called when connections is closed\n      * \n      * code?: number, \n      * reason?: string\n    */\n    socket.on('close', (code, reason) => { });\n\n    /**\n      * on 'error' will be called websocket connection has some issue\n      * \n      * err: Error \n    */\n    socket.on('error', (err) => { });\n\n    /**\n      * on 'pong' will be called when client response with pong to the server's ping message\n    */\n    socket.on('pong', () => { });\n\n    /**\n      * on 'ping' will only when ping is received (on clint side)\n    */\n    socket.on('ping', () => { });\n\n    /**\n      * 'send' method is used to send messages to the client / server\n      * \n      * message: string | binary\n      * options?: { binary?: boolean, compress?: boolean }\n      * cb?: function \n      * \n      * binary or string type detected automatically except\n      * if you force string type with `{ binary: false }`\n    */\n    socket.send(message, options, cb);\n\n\n    /**\n      * 'ping' method is used to manually send ping to the client\n    */\n    socket.ping();\n\n    /**\n      * 'terminate' method is used to kill connection (usually to remove dead sockets)\n    */\n    socket.terminate();\n\n    /**\n      * 'close' method is used close connection clean way\n      * \n      * code: number (close code)\n      * reason: string (the reason to close this socket)\n    */\n    socket.close(code, reason);\n});\n\n\n\n/**\n  * 'startAutoPing' method is method which will start auto ping all connected clients \n  * without any need for custom ping implementation\n  *  \n  * `startAutoPing` accepts 2 parameters\n  * interval: number\n  * appLevelPing: boolean (default false)\n  * \n  * `interval` specifies how often ping should be send to each client \n  * usually iyt would be around 20000 (in ms)\n  * \n  * `appLevelPing` is a value which allows you to ping any client including \n  * browser which do not expose `onping` and `onping` methods, for that to work you \n  * have to implement custom handle in you client side \n  * \n  * Check `Handle AppLevelPing In Browser Example` at the end of readme for more information\n*/\nserver.startAutoPing(interval, appLevelPing);\n\n\n/**\n *  `broadcast` method will send your message to all connected clients\n * accepts 2 parameters \n * message: string | binary,\n * options?: { binary: true | false }\n*/\nserver.broadcast(message, options);\n\n/** will close websocket server and call callback function after everything is done */\nserver.close(callback);\n\n\n/** \n * this on error will be called when there are some issues with create server or\n * upgrading socket connection properly\n */\nserver.on('error', (err, socket) => { })\n```\n\n\n### WebSocket Client\nWebsocket client pretty much has the same things as `socket` parameter passed in the server (above section) on new connection,\nbelow docs will cover mostly things which were not covered in above section.\n\n```js\nconst { WebSocket } = require('@clusterws/cws');\n\n/** this will connect to specify url */ \nconst socket = new WebSocket('ws://url:port');\n\n/** for more information about this listeners and functions check above section \n *  as client and server have similar signatures\n */ \nsocket.on('open', () => { })\nsocket.on('message', (msg) => { });\nsocket.on('error', (err) => { });\nsocket.on('close', (code, reason) => { });\nsocket.on('ping', () => { });\nsocket.on('pong', () => { });\nsocket.ping();\nsocket.send(msg);\nsocket.terminate();\nsocket.close(code, reason);\n\n/** \n * also websocket client support browser websocket signature \n * \n * Note that there is no onping and onpong as browsers dont expose this\n * functions to the users.\n */ \nsocket.onopen = () => {};\nsocket.onmessage = (msg) => {};\nsocket.onerror = (error) => {};\nsocket.onclose = (code, reason) => {};\n```\n\n\n## Additional Configuration/Examples\n\n### Replace EventEmitter \n\nCWS uses custom lightweight version of EventEmitter which may not be suitable for some people, to replace \nevent emitter you can use global cws configuration object ex:\n```js\n// this code uses default node js event emitter\nglobal.cws = {\n  EventEmitter: require('events').EventEmitter\n}\n\n// import cws\nconst { WebSocket } = require('@clusterws/cws');\n```\n\n### Handle AppLevelPing In Browser Example\nThis is just an example of handling app level `ping` `pong` from the client side which does not have `onping` and `onpong` methods available \n\n**Note** if your clients have `onping` and `onpong` methods (or similar) do not send `appLevel` ping from the server.\n\n```js\nconst ping = 57;\nconst pongResponse = new Uint8Array(['A'.charCodeAt()]);\n\nsocket.binaryType = 'arraybuffer' // Do not forget to set to `arraybuffer`\n\nsocket.onmessage = function (message) {\n    // check if our message if not string \n    if (typeof message.data !== 'string') {\n        // transform it to Unit Array\n        let buffer = new Uint8Array(message.data);\n\n        // Check if it is actually ping from the server\n        if (buffer[0] === ping && buffer.length === 1) {\n            // you can also emit that ping has been received to you client :)\n            // if it is then send back to the server pong response\n            return socket.send(pongResponse);\n        }\n\n      // process with your logic\n    }\n\n    // process with your logic\n}\n```\n",
    "licenseText": "This software is based on uWebSockets which has ZLIB license \nmake sure to check /src/LICENSE.\n\nFor the code provided by ClusterWS:\n\nMIT License\n\nCopyright (c) 2018 ClusterWS\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/@clusterws/cws/-/cws-0.15.0.tgz#1d585927252d1cd92e676c952fa6d69df14a0d07",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/@clusterws/cws/-/cws-0.15.0.tgz",
    "hash": "1d585927252d1cd92e676c952fa6d69df14a0d07",
    "integrity": "sha512-41QpCngw86n41hIdU5Nx2QJmmxZuA9FPtDkjONrYpk27L7HjL1kj6J5oWEjbr14yXLfigZit3VY+oACDCGbiHw==",
    "registry": "npm",
    "packageName": "@clusterws/cws",
    "cacheIntegrity": "sha512-41QpCngw86n41hIdU5Nx2QJmmxZuA9FPtDkjONrYpk27L7HjL1kj6J5oWEjbr14yXLfigZit3VY+oACDCGbiHw== sha1-HVhZJyUtHNkuZ2yVL6bWnfFKDQc="
  },
  "registry": "npm",
  "hash": "1d585927252d1cd92e676c952fa6d69df14a0d07"
}